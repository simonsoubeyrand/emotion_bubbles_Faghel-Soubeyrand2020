function cid = readCid2(fileName)% READCIDB Reads the fileName classification image data file in CID format. Outputs cid a structure% 	containing the fields: origins,info, noise, dataLabels (all strings), and data (a matrix of doubles).% 		E.g., cid = readCid('AGBTSD05.cid');%% 	CID files are in ASCII. See AGBTSD04.cid provided with the Stat4Ci toolbox, for a full example.% 	The format of CID files is as follows:%%% 	[INFORMATION]% 	Necessary section (and title). Free text such as this. Should contain the rationale, methods,% 	and main results of the experiment. And other relevant information.%% 	[NOISE]% 	Necessary section (and title). Must contain the definition of the MAKETHENOISE function. This% 	function inputs oneTrial a vector with all the data from one particular trial, and outputs% 	theNoise, the trial's sampling noise, and tmpState, the state of the pseudo-random number% 	generator. The number -99 is reserved within the DATA section; it means: this parameter% 	hasn't been updated. The following MAKETHENOISE function, for example, generates a 256 x 256% 	pixels Gaussian white noise field on each trial using the RANDN Matlab function; whenever% 	the number in the seed data column is updated it is given to the pseudo-random number generator;% 	otherwise, tmpState{N} is given to the Nth pseudo-random number generator.%% 	function [theNoise, tmpState]=makeTheNoise(oneTrial,tmpState)% 	if(oneTrial(4)==-99)% 		randn('state',tmpState{1});% 	else%		randn('state',oneTrial(4));%	end%	theNoise = randn(256, 256);%	tmpState{1}=randn('state');%% 	[TRANSFORMATION]%	Necessary section (and title).%%	[CONSTANTS]%	Necessary section (and title).%% 	[DATA LABELS]% 	Necessary section (and title). Free text such as this. Should label all the data columns.%% 	[NUMBER OF TRIALS]% 	Necessary section (and title). Should contain the number of data lines. Speeds things up.%% 	[DATA]% 	Necessary section (and title). Each line corresponds to a trial; each TAB-separated column to a% 	different type of data (e.g., subject, block, seed) . Everything required to regenerate the sampling% 	noise must be given. Each line should contain the same number of columns. The number -99 is reserved;% 	it means: the data in this column hasn't been updated. E.g.:%% 	1	1	1	212040.400000	1	1	1	1	50.000000	3.040000% 	1	1	1	-99	1	1	2	1	50.000000	7.720000% 	...%% See also BUILDCI, DEMO4CI%% The Stat4Ci toolbox is free (http://mapageweb.umontreal.ca/gosselif/stat4ci.html); if you use% it in your research, please, cite us:%	Chauvin, A., Worsley, K. J., Schyns, P. G., Arguin, M. & Gosselin, F. (2004).  A sensitive%	statistical test for smooth classification images.%% Alan Chauvin & Fr�d�ric Gosselin (frederic.gosselin@umontreal.ca), 20/08/2004% Add automatically the number of trials in the constants section; and save; check whether it's ok also.if(~findstr('.pcid', fileName))    error('Unrecognized classification image data format.');endid = fopen(fileName,'r');if (id == -1)    error('File not found')endinfo = '';noise = '';constants = '';tdataLabels = '';template = '';whichTrial = 0;tag = 1;first = 1;while 1    oneLine = fgets(id);    if ~isstr(oneLine), break, end    if(findstr('[INFORMATION]', oneLine) & (tag == 1))        tag = 2;    elseif(findstr('[NOISE]', oneLine) & (tag == 2))        tag = 3;    elseif(findstr('[CONSTANTS]', oneLine) & (tag == 3))        tag = 4;    elseif(findstr('[DATA LABELS]', oneLine) & (tag == 4))        tag = 5;    elseif(findstr('[DATA]', oneLine) & (tag == 5))        tag = 6;    else        switch tag            case 0                error('Data file not properly formatted.')            case 1                error('This is impossible.')            case 2                info = [info, oneLine];            case 3                noise = [noise, oneLine];            case 4                constants = [constants, oneLine];            case 5                tdataLabels = [tdataLabels, oneLine];            case 6                whichTrial = whichTrial + 1;                if(first)                    eval(constants);                    temp = sscanf(oneLine, '%f');                    nbColumns = length(temp);                    if ~exist('nbTrials','var')                        data = zeros(nbColumns, 1);                        data(:, whichTrial) = temp;                        fprintf('\n%d trials read.', whichTrial);                    else                        data = zeros(nbColumns, nbTrials);                        data(:, whichTrial) = temp;                        fprintf('\n%d%% of trials read.', round(100*whichTrial/nbTrials));                    end                    first = 0;                else                    data(:, whichTrial) = sscanf(oneLine, '%f');                    if ~exist('nbTrials','var')                        nbBack = length(num2str(whichTrial-1));                        back = '\b\b\b\b\b\b\b\b\b\b\b\b\b';                        for ii = 1:nbBack, back = [back, '\b']; end                        eval(sprintf('fprintf(''%s%d trials read.'')', back, whichTrial));                    else                        back = '\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b';                        nbBack = length(num2str(round(100*(whichTrial-1)/nbTrials)));                        for ii = 1:nbBack, back = [back, '\b']; end                        eval(sprintf('fprintf(''%s%d%s of trials read.'')', back, round(100*whichTrial/nbTrials),'%%'))                    end                end            otherwise                error('This is impossible.')        end    endendfprintf('\n');fclose(id);cid.info = info;cid.noise = noise;id = fopen('MAKETHENOISE.m', 'w');fprintf(id, '%s', noise);fclose(id);cid.constants = constants;eval(constants)%cid.dataLabels = dataLabels;cid.dataLabels = segmentStr(tdataLabels);cid.data = data;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function aCell = segmentStr(aString)separator{1} = char(13);    % newlineseparator{2} = char(10);    % another newlineseparator{3} = char(32);    % spaceseparator{4} = char(9);     % tabtemp = '';for ii = 1:length(separator),    test = findstr(aString, separator{ii});    if ~isempty(test)        temp = test;    endendif isempty(temp)    aCell{1} = 'Could not segment the data labels.';else    marker = 0;    str = aString(1:temp(1)-1);    if ~isempty(str)        marker = marker + 1;        aCell{marker} = str;    end    for ii = 2:length(temp),        str = aString(temp(ii-1)+1:temp(ii)-1);        if ~isempty(str)            marker = marker + 1;            aCell{marker} = str;        end    end    str = aString(temp(end)+1:end);    if ~isempty(str)        marker = marker + 1;        aCell{marker} = str;    endend